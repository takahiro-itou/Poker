# Pattern Generator

##  Abstract.

このプログラムでは 52 枚のカードの中から 5～7 枚を選ぶ組み合わせを
全て列挙し、その各パターンに対して何らかの判定処理を行う。
このディレクトリにあるモジュールは、
組み合わせの全パターンを列挙するアルゴリズムを実装する。

##  Introduction.

もっとも単純だが良くない実装としては、
以下のプログラムの様に多重ループで実装する方法がある
（オリジナルは VB6 だが C 言語で書き直した）。

https://gitlab.com/takahiro-itou-vb6backup/Poker/-/blob/master/Tables.bas#L200

```
for (c0 = 0; c0 <= 47; ++ c0) {
  for (c1 = c0 + 1; c1 <= 48; ++ c1) {
    for (c2 = c1 + 1; c2 <= 49; ++ c2) {
       for (c3 = c2 + 1; c3 <= 50; ++ c3) {
         for (c4 = c3 + 1; c4 <= 51; ++ c4) {
            doSomething(c0, c1, c2, c3, c4);
         }
      }
    }
  }
}
```

このコードは 52 枚中 5 枚選ぶロジックだが、
これでは 52 枚中 6 枚とか 6 枚に変更しようとすると、
コードの大幅な変更を余儀なくされる。
これを以下のように書き換えられるようにする。

```
N = 52;
R = 5;
Generator gen(N, R);

gen.resetGenerator();
do {
    const Generator::Pattern & pattern = gen.getCurrent();
    doSomething(pattern);
} while ( gen.generateNext() );
```

こうしておけば、組み合わせの数字が変わっても、
最初の部分で、コンストラクタの引数を変更するだけで対応でき、
それ以外のロジックは変更しないで良くなる。

イメージとしては
resetGenerator() で最初のパターンを生成し、
generateNext() を呼び出すごとに次のパターンを生成する。
ただし、次がなければ false を返す。
この時、generateNext() の中で、
（深さが、N や R といったパラメータに依存する）
多重ループを使ってしまうと、問題点を関数の中に押し込んだだけで
何の解決にもならないので注意。

なお、実際には高速化のためテンプレートにしている。
そしてパラメータ N と R は、コンストラクタの引数ではなく、
テンプレート引数になっている。
このため N と R はコンパイル時定数でなければならない。
そうでない場合は、このプログラムを修正して使うこと。

##  アルゴリズム

以下のセクションでは、generateNext() メンバ関数の実装について説明する。

###   共通事項

- 内部で現在のパターンをメンバ変数 m_buf[R] に持つ。
- resetGenerator() を呼ぶと m_buf を最初のパターンにリセットする。
- generateNext() を呼ぶごとに  m_buf を次のパターンに更新する。

実装の都合により、パターンは小さい順に生成するものとする。
たとえば、N=5, R=3 の時、重複順列なら

```
111
112
113
114
115
121
...
555
```

の順である。組み合わせなら

```
123
124
125
134
135
145
234
235
245
345
```

の順になる。順列なら

```
123
124
125
132
134
135
...
531
532
534
541
542
543
```

###  重複順列

- [コード](RepeatedPermutationGenerator.inl)

最も簡単なのは重複順列である。
これは m_buf を N 進数 R 桁の数値と見做した時、
単純に +1 を行うだけでよい。
つまり、一番下の位をインクリメントすればよく、
それが N を超えた時は、繰り上がりの処理を行えばよい。

- [初期化](RepeatedPermutationGenerator.inl#L88) は、11...1 になるように行う。
- [更新](RepeatedPermutationGenerator.inl#L101) は
    - 一番下の位に +1 する (Line 107)
        - 繰り上がりがなければ終了 (Line 108)
        - 繰り上がったら、その位を 1 に戻して(Line 110)、次の位へループする。
    - もしすべての位で繰り上がったら、最後まで列挙した (Line 113)

###  組み合わせ

- [コード](CombinationGenerator.inl)

次に簡単なのは組み合わせである。
組み合わせの場合
123, 132, 213, 231, 312, 321 はすべて同じものと見做されるので、
昇順に並ぶ 123 だけを生成するものとする。
内部状態 m_buf は m_buf[i] < m_buf[i+1] を満たすようにする。
この時 i 番目の位は最大で、N - R - i である
（0-オリジンか1-オリジンかで微妙に数式が変わることに注意）。

- [初期化](CombinationGenerator.inl#L88) は 123..R となるように行う。
- [更新](CombinationGenerator.inl#101) は
    - 一番下 (右) の位に +1 する (Line 108)
        - これがその位の最大値を超えない場合はループを終了する (Line 109)
        - そうでなければ、次の位に移動して同様にインクリメントを試みる
    - 最後にインクリメントした位より右を最小値にセットする (Line 118)
        - 最小値は、その位の一つ上（左）の位の数字 + 1 である

###  順列

- 未実装
